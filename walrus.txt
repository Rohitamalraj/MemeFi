Walrus and Sui
Walrus depends on Sui, as it leverages Sui to track blobs, their respective owners, and their lifetimes.

Sui and Walrus are both decentralized, distributed systems made up of many independent servers that communicate and collectively establish shared state. A group of servers together is a network.

Available networks
Sui and Walrus each have the following available networks:

Testnet is a sandbox-like network where you can receive test tokens for free to use for the network's fees. You can build, test, and debug software packages on Testnet. Testnet does not guarantee data persistence and might wipe data at any time without warning.
Mainnet is a production environment where you use real tokens and users or other applications rely on consistent functionality.
When you are getting started, you should use Testnet.

Step 1: Install tooling
To install Walrus and Sui, use the Mysten Labs suiup tool.

Install suiup:

    $ curl -sSfL https://raw.githubusercontent.com/Mystenlabs/suiup/main/install.sh | sh

 Copy
Install sui and walrus:

    $ suiup install sui
    $ suiup install walrus

 Copy
Step 2: Configure tooling for Walrus Testnet
After installing Walrus it is important to configure the Walrus client
, which tells it the RPC URLs to use to access Testnet or Mainnet, and the Sui objects that track the state of the Walrus network. The easiest way to configure Walrus is to download the following pre-filled configuration file.

Download the configuration file:

    $ curl --create-dirs https://docs.wal.app/setup/client_config.yaml -o ~/.config/walrus/client_config.yaml

 Copy
Configure the Sui client to connect to Testnet.

The Sui client configuration is separate from the Walrus client configuration. Learn more about the Sui client configuration.

Initialize the Sui client:

    $ sui client

 Copy
When prompted, enter the following:

Connect to a Sui Full Node server? → Y
Full node server URL → https://fullnode.testnet.sui.io:443
Environment alias → testnet
Select key scheme → 0 (for ed25519)
This creates your Sui client configuration file with a Testnet environment and generates your first address.

To confirm the Walrus configuration also uses Testnet, run the command:

    $ walrus info

 Copy
Make sure that this command's output includes Epoch duration: 1day to indicate connection to Testnet.

For detailed information about the walrus command-line tool, use the walrus --help command. Or, append --help to any walrus subcommand to get details about that specific command.

Step 3: Understanding your Sui account
When you ran sui client during setup, the system automatically created a Sui account for you. Sui uses addresses and accounts. When you store blobs on Walrus, Walrus binds them to an object on Sui that an address owns.

An address is a unique location on the blockchain. A 32-byte identifier (displayed as 64 hex characters with 0x prefix) identifies the address, which can own objects. The system derives the address from a public key using a hash function.

Anyone can see addresses, and they are valid on all networks (Testnet, Mainnet, and so on), but networks do not share data and assets.

An account is an address plus the key to access it. If you have an address's private key, you have privileged access and control over what the address owns, such as tokens and objects.

To view your active address, run:

sui client active-address

 Copy
To see all your addresses and their key schemes, run:

sui client addresses

 Copy
Store your keys securely
You must store your private key and recovery passphrase securely, otherwise you might lose access to your address.

Learn more about addresses, available key pair options, and key storage.

Creating additional addresses (optional)

You can create additional addresses if needed:

sui client new-address ed25519

 Copy
The argument ed25519 specifies the key pair scheme to be of type ed25519.

Step 4: Fund Sui account with tokens
Before you can upload a file to Walrus and store it as a blob, you need SUI tokens to pay transaction fees and WAL
 tokens to pay for storage on the network. The Walrus Testnet uses Testnet WAL tokens that have no value and you can exchange them at a 1:1 rate for Testnet SUI tokens.

Navigate to the SUI Testnet faucet: https://faucet.sui.io/

Ensure you select Testnet.

Then, insert your Sui address. To print your Sui address, use the command:

    $ sui client active-address

 Copy
After you insert your address on the faucet and receive a message saying you have received SUI tokens, check your balance with the command:


    $ sui client balance

 Copy
Faucet alternatives
The Sui faucet is rate limited. If you encounter errors or have questions, you can request tokens from the Discord faucet or a third party faucet. Learn more about the Sui faucet.

Convert some of those SUI tokens into WAL with the command:

    $ walrus get-wal --context testnet

 Copy
Check your balance again with sui client balance to confirm you now have WAL:

    ╭─────────────────────────────────────────╮
    │ Balance of coins owned by this address  │
    ├─────────────────────────────────────────┤
    │ ╭─────────────────────────────────────╮ │
    │ │ coin  balance (raw)     balance     │ │
    │ ├─────────────────────────────────────┤ │
    │ │ Sui        497664604      0.49 SUI  │ │
    │ │ WAL Token  500000000      0.50 WAL  │ │
    │ ╰─────────────────────────────────────╯ │
    ╰─────────────────────────────────────────╯

 Copy
Step 5: Store a blob
Changes to objects on Sui happen through the use of transactions. Accounts sign these transactions on behalf of addresses and they result in the system creating, updating, transferring, and sometimes destroying objects. Learn more about transactions.

To upload a file to Walrus and store it as a blob, run the following command:

walrus store file.txt --epochs 2 --context testnet

 Copy
Replace file.txt with the file you want to store on Walrus. You can store any file type on Walrus.

You must specify the --epochs flag, as the system stores blobs for a certain number of epochs. An epoch is a certain period of time on the network. On Testnet, epochs are 1 day, and on Mainnet epochs are 2 weeks. You can extend the number of epochs the system stores a blob indefinitely.

The system uploads a blob in slivers, which are small pieces of the file the system stores on different servers through erasure coding. Learn more about the Walrus architecture and how the system implements erasure coding.

After you upload a blob
 to Walrus, it has 2 identifiers:

Blob ID: oehkoh0352bRGNPjuwcy0nye3OLKT649K62imdNAlXg
Sui object ID: 0x1c086e216c4d35bf4c1ea493aea701260ffa5b0070622b17271e4495a030fe83

 Copy
Blob ID
: A way to reference the blob on Walrus. The system generates the blob ID based on the blob's contents, meaning any file you upload to the network twice results in the same blob ID.

Sui Object ID: The blob's corresponding newly created Sui object identifier, as the system binds all blobs to one or more Sui objects.

You use blob IDs to read blob data, while you use Sui object IDs to make modifications to the blob's metadata, such as its storage duration. You might also use them to read blob data.

You can use the Walrus Explorer to view more information about a blob ID
.

Step 6: Retrieve a blob
To retrieve a blob and save it on your local machine, run the following command:

walrus read <blob-id> --out file.txt --context testnet

 Copy
Replace <blob-id> with the blob's identifier the walrus store command returns in its output, and replace file.txt with the name and file extension for storing the file locally.

Step 7: Extend a blob's storage duration
To extend a blob's storage duration, you must reference the Sui object ID and indicate how many epochs you want to extend the blob's storage for.

Run the following command to extend a blob's storage duration by 3 epochs. You must use the Sui object ID, not the blob ID:

walrus extend --blob-obj-id <blob-object-id> --epochs-extended 3 --context testnet

 Copy
Replace <blob-object-id> with the blob's Sui object ID the walrus store command returns in its output.

Step 8: Delete a blob
All blobs stored in Walrus are public and discoverable by anyone. The delete command does not delete blobs from caches, slivers from past storage nodes
, or copies that could have been made by users before the blob was deleted.

To delete a blob, run the following command:

walrus delete --blob-id <blob-id> --context testnet

 Copy
Replace <blob-id> with the blob's identifier the walrus store command returns in its output.

Next steps
Build your first Walrus application. Explore working examples:

Python examples
JavaScript web form
Move smart contracts
Need help?
Troubleshooting guide
Discord community
Edit this page

Storing Blobs
Use the command-line interface (CLI) to interact with the Walrus client
. The CLI is available through installing the walrus binary. See the getting started documentation for prerequisites, installation, and configuration.

Detailed usage information including a full list of available commands can be viewed using:

walrus --help

 Copy
Each subcommand of walrus can also be called with --help to print its specific arguments and their meaning.

If you have multiple contexts in your configuration file, you can specify the context for each command using the --context option. You can generate a bash, zsh, or fish completion script with walrus completion and place it in an appropriate directory like ~/.local/share/bash-completion/completions.

Store blobs
All blobs stored in Walrus are public and discoverable by all. To store sensitive data, use Seal or Nautilus to encrypt the data before storing it on Walrus.

Store blobs on Walrus with the following command:

walrus store <FILES> --epochs <EPOCHS>

 Copy
After you upload a blob
 to Walrus, it has 2 identifiers:

Blob ID: oehkoh0352bRGNPjuwcy0nye3OLKT649K62imdNAlXg
Sui object ID: 0x1c086e216c4d35bf4c1ea493aea701260ffa5b0070622b17271e4495a030fe83

 Copy
Blob ID
: A way to reference the blob on Walrus. The system generates the blob ID based on the blob's contents, meaning any file you upload to the network twice results in the same blob ID.

Sui Object ID: The blob's corresponding newly created Sui object identifier, as the system binds all blobs to one or more Sui objects.

You use blob IDs to read blob data, while you use Sui object IDs to make modifications to the blob's metadata, such as its storage duration. You might also use them to read blob data.

You can store a single file or multiple files, separated by spaces. Notably, this is compatible with glob patterns; for example, walrus store *.png --epochs <EPOCHS> stores all PNG files in the current directory.

Blob lifetimes
A mandatory CLI argument must be set to specify the lifetime for the blob. There are currently 3 methods of setting a blob's lifetime:

The --epochs <EPOCHS> option indicates the number of epochs the blob should be stored for. There is an upper limit on the number of epochs a blob can be stored for, which is 53 and corresponds to 2 years. In addition to a positive integer, you can also use --epochs max to store the blob for the maximum number of epochs. The end epoch is defined as the current epoch plus the specified number of epochs.

The --earliest-expiry-time <EARLIEST_EXPIRY_TIME> option takes a date in either RFC3339 format (for example, 2024-03-20T15:00:00Z) or a more relaxed format (for example, 2024-03-20 15:00:00). It ensures the blob expires after the specified date if possible.

The --end-epoch <END_EPOCH> option takes a specific end epoch for the blob.

A blob expires at the beginning of its end epoch. For example, a blob with end epoch 314 becomes unavailable at the beginning of epoch 314. One consequence of this is that when storing a blob with --epochs 1 immediately before an epoch change, it expires and becomes unavailable almost immediately. Blobs can be extended only if they have not expired.

Blob permanence
You can specify whether a newly stored blob is deletable or permanent through the --deletable and --permanent option, respectively:

A permanent blob
 remains available until its expiry
 epoch. Not even the uploader can delete it beforehand.

In contrast, a deletable blob
 can be deleted at any point during its lifetime by the owner of the corresponding Sui object. See the deletable blobs for more details.

Newly stored blobs are deletable by default.

Automatic optimizations
When storing a blob, the client performs a number of automatic optimizations, including the following:

If the blob is already stored as a permanent blob on Walrus for a sufficient number of epochs, the command does not store it again. This behavior can be overwritten with the --force CLI option, which stores the blob again and creates a fresh Sui object belonging to the wallet address.

If the user
's wallet has a storage resource of suitable size and duration, it is used instead of requiring that the user buy a new one.

If the blob is already certified on Walrus but it is a deletable blob or it is not stored for a sufficient number of epochs, the command skips sending encoded blob data to the storage nodes
 and just collects the availability certificate.

Use a Walrus upload relay
A Walrus upload relay is a third party service that can help clients with limited bandwidth and networking capabilities such as a browser, for example, in storing blobs on Walrus.

Asset management on-chain still happens on the client. The upload relay just takes the unencoded blob, encodes it, and sends the slivers to the storage nodes, before returning the certificate. See in-depth details in the Walrus upload relay documentation.

When storing blobs with the walrus store command, and also when storing quilts, you can use the --upload-relay flag with a URL to specify an upload relay server be used by the CLI.

The Walrus upload relay functionality is only available in the Walrus CLI version v1.29 or higher.

The upload relay is a third party service that might require a fee or tip. This tip might be a constant SUI amount per blob stored, or it might be dependent on the size of the blob being stored. The Walrus CLI shows you how much tip the upload relay requires and asks for confirmation before continuing.

View technical details on how the tip is computed and paid.

Store blobs as a quilt
For efficiently storing large numbers of small blobs, Walrus provides the Quilt. It batches multiple blobs into a single storage unit, significantly reducing overhead and cost. You can find a more detailed overview of the feature Quilt.

You can interact with quilts using a dedicated set of walrus subcommands.

Blobs within a quilt are retrieved by a QuiltPatchId, not their standard BlobId. This ID is generated based on all blobs in the quilt, so a blob's QuiltPatchId changes if it's moved to a different quilt.

Standard blob operations like delete, extend, or share cannot target individual blobs inside a quilt; they must be applied to the entire quilt.

To store all files from one or more directories recursively, use the --paths flag. The filename of each file is used as its unique identifier within the quilt. Regular expressions are supported for uploading from multiple paths.

Like the regular store command, you can specify the storage duration using --epochs, --earliest-expiry-time, or --end-epoch.

walrus store-quilt --epochs <EPOCHS> --paths <path-to-directory-1> <path-to-directory-2> <path-to-blob>

 Copy
You must ensure that all the identifiers are unique within a quilt, the operation fails otherwise. Identifiers are the unique names used to retrieve individual blobs from within the quilt.

To specify a list of blobs as JSON objects, use the --blobs flag. This gives you more control, allowing you to set a custom identifier and tags for each file. If identifier is null or omitted, the file's name is used instead.

walrus store-quilt \
    --blobs '{"path":"<path-to-blob-1>","identifier":"walrus","tags":{"color":"grey","size":"medium"}}' \
            '{"path":"<path-to_blob-2>","identifier":"seal","tags":{"color":"grey","size":"small"}}' \
    --epochs <EPOCHS>

 Copy
Edit this page

Reading Blobs
The status of a blob
 can be queried through one of the following commands:

walrus blob-status --blob-id <BLOB_ID>
walrus blob-status --file <FILE>

 Copy
Each command returns output that indicates whether the specified blob is stored and its availability period
. If you specify a file with the --file option, the CLI re-encodes the content of the file and derives the blob ID
 before checking the status.

When a blob is available, the blob-status command also returns the BlobCertified Sui event ID, which consists of a transaction ID and a sequence number in the events emitted by the transaction. The existence of this event certifies the availability of the blob.

Read blobs
Reading blobs from Walrus can be achieved using the following command:

walrus read <some blob ID>

 Copy
By default, blob data is written to the standard output. The --out <OUT> CLI option can be used to specify an output file name. The --rpc-url <URL> can be used to specify a Sui RPC node to use instead of the currently configured RPC node set in the CLI configuration file or wallet configuration.

Check consistency
Walrus performs integrity and consistency checks to ensure that any data read from Walrus is what the writer intended, and that the writer encoded the blob correctly. See the data consistency documentation for further details.

Prior to v1.37, the Walrus CLI and aggregator
 always performed the strict consistency check. Starting with v1.37, the default is a more performant consistency check, which is sufficient for the majority of cases. The strict consistency check can be enabled through the flag --strict-consistency-check.

Consistency checks can be disabled completely with the flag --skip-consistency-check. This should only be used if the writer of the blob is known and trusted.

Read blobs from a quilt
You can retrieve individual blobs from a quilt without downloading the entire quilt. The read-quilt command allows you to query for specific blobs by their identifier, tags, or unique blob ID.

To read blobs by their identifiers, use the --identifiers flag:

walrus read-quilt --out <download dir> \
    --quilt-id 057MX9PAaUIQLliItM_khR_cp5jPHzJWf-CuJr1z1ik --identifiers walrus.jpg another-walrus.jpg

 Copy
Blobs within a quilt can be accessed and filtered based on their tags. For instance, if you have a collection of animal images stored in a quilt, each labeled with a species tag such as species=cat, you can download all images labeled as cats with the following command:

walrus read-quilt --out <download dir> \
    --quilt-id 057MX9PAaUIQLliItM_khR_cp5jPHzJWf-CuJr1z1ik --tag species cat

 Copy
You can also read a blob using its QuiltPatchId, which can be retrieved using walrus list-patches-in-quilt:

walrus read-quilt --out <download dir> \
  --quilt-patch-ids GRSuRSQ_hLYR9nyo7mlBlS7MLQVSSXRrfPVOxF6n6XcBuQG8AQ \
  GRSuRSQ_hLYR9nyo7mlBlS7MLQVSSXRrfPVOxF6n6XcBwgHHAQ

 Copy
To see all the patches contained within a quilt, along with their identifiers and QuiltPatchIds, use the list-patches-in-quilt command.

walrus list-patches-in-quilt 057MX9PAaUIQLliItM_khR_cp5jPHzJWf-CuJr1z1ik

 Copy
Edit this page

# Managing Blobs

URL: https://docs.wal.app/docs/walrus-client/managing-blobs

## Extend the lifetime of a blob **Blob** Single unstructured data object stored on Walrus.

Walrus blob lifetimes can be extended using the `walrus extend --blob-obj-id <Sui object id> ...` command as long as the blob is not expired. Both address owned blobs and shared blobs can have their lifetime extended. Shared blobs can be extended by anyone, but owned blobs can only be extended by their owner. When extending a shared blob , you need to supply the `--shared` flag to inform the command that the blob is shared.

The blob 's object ID is needed in order to extend it. The blob ID **Blob ID** Cryptographic ID computed from a blob's slivers. is not needed. See `walrus extend --help` for more information on blob extension.

## Reclaim space through deletable blobs

A blob that was set as deletable upon creation can be deleted before its expiry **Expiry** The end epoch at which a blob is no longer available and can be deleted; the end epoch is always exclusive. , but only by the owner of the Sui object corresponding to the blob . Deletable blobs are indicated as such in the Sui events that certify them, and should not be relied upon by others for availability.

Delete a blob with the command:

```sh
$ walrus delete --blob-id <BLOB_ID>
```

The delete command can also be invoked by specifying a `--file <PATH>` option to derive the blob ID from a file, or using `--object-id <SUI_ID>` . Before deleting a blob , the `walrus delete` command asks for confirmation unless the `--yes` option is specified.

The `delete` command reclaims the storage object associated with the deleted blob , which is re-used to store new blobs automatically. The delete operation provides flexibility around managing [storage costs](/docs/system-overview/storage-costs) and re-using storage.

The delete operation has limited utility for privacy. It only deletes slivers from the current epoch storage nodes **Storage node** Entity storing data for Walrus; holds one or several *shards*. , and subsequent epoch storage nodes , if no other user **User** Any entity or person that wants to store or read blobs on or from Walrus; can act as a Walrus client itself or use the simple interface exposed by publishers and caches. has uploaded a copy of the same blob . If another copy of the same blob exists in Walrus, the delete operation does not make the blob unavailable for download, and `walrus read` invocations will still download it. After the deletion is finished, the CLI checks the updated status of the blob to see if it is still accessible in Walrus, unless the `--no-status-check` option was specified. However, even if the blob is not accessible, copies of the public blob might be cached or downloaded by users, and these copies are not deleted.

danger
All blobs stored in Walrus are public and discoverable by all. The `delete` command does not delete slivers if other copies of the blob are stored on Walrus, possibly by other users. It does not delete blobs from caches, slivers from past storage nodes , or copies that could have been made by users before the blob was deleted.

## Shared blobs

Shared blobs are shared Sui objects wrapping standard `Blob` objects that can be funded and whose lifetime can be extended by anyone. See the [shared blobs contracts](https://github.com/MystenLabs/walrus/tree/main/contracts/walrus/sources/system/shared_blob.move) for further details.

You can create a shared blob from an existing `Blob` object you own with the `walrus share` command:

```sh
$ walrus share --blob-obj-id <SUI_OBJ_ID>
```

The resulting shared blob can be directly funded by adding an `--amount` , or you can fund an existing shared blob with the `walrus fund-shared-blob` command. Additionally, you can immediately share a newly created blob by adding the `--share` option to the `walrus store` command.

Shared blobs can only contain permanent blobs and as such cannot be deleted before their expiry .

Learn more about blob extension.

# JSON Mode

URL: https://docs.wal.app/docs/walrus-client/json-mode

All Walrus client **Client** Entity interacting directly with the storage nodes; this can be an aggregator or cache, a publisher, or an end user. commands are available in JSON mode, simplifying programmatic access to the [CLI](/docs/walrus-client/storing-blobs) . All the command-line flags of the original CLI command can be specified in JSON format.

For example, to store a blob **Blob** Single unstructured data object stored on Walrus. , run:

```sh
$ walrus json \
    '{
        "config": "path/to/client_config.yaml",
        "command": {
            "store": {
                "files": ["README.md", "LICENSE"],
                "epochs": 100
            }
        }
    }'
```

Or, to read a blob using the blob ID **Blob ID** Cryptographic ID computed from a blob's slivers. :

```sh
$ walrus json \
    '{
        "config": "path/to/client_config.yaml",
        "command": {
            "read": {
                "blobId": "4BKcDC0Ih5RJ8R0tFMz3MZVNZV8b2goT6_JiEEwNHQo"
            }
        }
    }'
```

All options, default values, and commands are equal to those of the [standard CLI mode](/docs/walrus-client/storing-blobs) , except that they are written in camelCase instead of kebab-case.

The `json` command also accepts input from `stdin` .

The output of a `json` command is itself JSON-formatted to simplify parsing the results in a programmatic way. For example, the JSON output can be piped to the `jq` command for parsing and manually extracting relevant fields.

# Configuration

URL: https://docs.wal.app/docs/walrus-client/configuration

Use the `--config` option to specify a custom path to the [configuration location](/docs/getting-started/advanced-setup#configuration) .

The `--wallet <WALLET>` argument can be used to specify a non-standard Sui wallet configuration file and a `--gas-budget <GAS_BUDGET>` argument can be used to change the maximum amount of Sui (in MIST) that the command is allowed to use.

# Logging and Metrics

URL: https://docs.wal.app/docs/walrus-client/logging-and-metrics

The `walrus` CLI allows for multiple levels of logging, which can be turned on through an environment variable:

```sh
$ RUST_LOG=walrus=trace walrus info
```

By default `info` level logs are enabled, but `debug` and `trace` can give a more in depth understanding of what a command does or how it fails.

Storing Blobs
You can store data using HTTP PUT requests. For example, with cURL, you can store blobs
 using a publisher
:

# Store the string `some string` for 1 storage epoch
curl -X PUT "$PUBLISHER/v1/blobs" -d "some string"
# Store file `some/file` for 1 storage epoch
curl -X PUT "$PUBLISHER/v1/blobs" --upload-file "some/file"

 Copy
Control how the new blob is created through a combination of several query parameters as documented in the OpenAPI specification. For example:

Specify the lifetime of the blob through the epochs parameter. If the parameter is omitted, blobs are stored for 1 epoch.

# Store file `some/file` for 5 storage epochs
curl -X PUT "$PUBLISHER/v1/blobs?epochs=5" --upload-file "some/file"

 Copy
Specify whether a blob is stored as permanent or deletable through a query parameter permanent=true or deletable=true, respectively:

# Store file `some/file` as a deletable blob:
curl -X PUT "$PUBLISHER/v1/blobs?deletable=true" --upload-file "some/file"

 Copy
# Store file `some/file` as a permanent blob:
curl -X PUT "$PUBLISHER/v1/blobs?permanent=true" --upload-file "some/file"

 Copy
warning
Newly stored blobs are deletable by default.

Specify an address to which the resulting Blob object is sent using the send-object-to parameter:

# Store file `some/file` and send the blob object to `$ADDRESS`:
curl -X PUT "$PUBLISHER/v1/blobs?send_object_to=$ADDRESS" --upload-file "some/file"

 Copy
The store HTTP API endpoints return information about stored blobs in JSON format. When a blob is stored for the first time, a newlyCreated field contains information about it:

curl -X PUT "$PUBLISHER/v1/blobs" -d "some other string"

 Copy
If successful, the console responds with the information stored in the content of the blob's corresponding Sui object. :

{
  "newlyCreated": {
    "blobObject": {
    "id": "0xe91eee8c5b6f35b9a250cfc29e30f0d9e5463a21fd8d1ddb0fc22d44db4eac50",
    "registeredEpoch": 34,
    "blobId": "M4hsZGQ1oCktdzegB6HnI6Mi28S2nqOPHxK-W7_4BUk",
    "size": 17,
    "encodingType": "RS2",
    "certifiedEpoch": 34,
    "storage": {
        "id": "0x4748cd83217b5ce7aa77e7f1ad6fc5f7f694e26a157381b9391ac65c47815faf",
        "startEpoch": 34,
        "endEpoch": 35,
        "storageSize": 66034000
    },
    "deletable": false
    },
    "resourceOperation": {
    "registerFromScratch": {
        "encodedLength": 66034000,
        "epochsAhead": 1
    }
    },
    "cost": 132300
  }
}

 Copy
When the publisher finds a certified blob with the same blob ID
 and a sufficient validity period, it returns an alreadyCertified JSON structure:

{
  "alreadyCertified": {
    "blobId": "M4hsZGQ1oCktdzegB6HnI6Mi28S2nqOPHxK-W7_4BUk",
    "event": {
    "txDigest": "4XQHFa9S324wTzYHF3vsBSwpUZuLpmwTHYMFv9nsttSs",
    "eventSeq": "0"
    },
    "endEpoch": 35
  }
}

 Copy
The field event returns the Sui event ID that can be used to find the object creation transaction using a Sui Explorer or using a Sui SDK.

Edit this page

# Reading Blobs

URL: https://docs.wal.app/docs/http-api/reading-blobs

You can read blobs **Blob** Single unstructured data object stored on Walrus. using HTTP GET requests and their blob ID **Blob ID** Cryptographic ID computed from a blob's slivers. or object ID.

### Blob IDs

For example, the following cURL command reads a blob and writes it to an output file:

```sh
$ curl "$AGGREGATOR/v1/blobs/<some blob ID>" -o <some file name>
```

Alternatively, you can print the contents of a blob in the terminal with the cURL command:

```sh
$ curl "$AGGREGATOR/v1/blobs/<some blob ID>"
```

tip
Modern browsers attempt to sniff the content type for such resources, and generally do a good job of inferring content types for media. However, the aggregator **Aggregator** Service that reconstructs blobs by interacting with storage nodes and exposes a basic `HTTP GET` endpoint to end users. on purpose prevents such sniffing from inferring dangerous executable types such as JavaScript or style sheet types.

### Object ID

You can also read blobs by using the object ID of a Sui blob object or a shared blob . For example, the following cURL command downloads the blob corresponding to a Sui object ID:

```sh
$ curl "$AGGREGATOR/v1/blobs/by-object-id/<object-id>" -o <some file name>
```

Downloading blobs by object ID allows setting some HTTP headers. The aggregator recognizes the following attribute keys and returns the values in the corresponding HTTP headers when present:

- `content-disposition`
- `content-encoding`
- `content-language`
- `content-location`
- `content-type`
- `link`

### Consistency checks

The consistency checks performed by the aggregator are the same as the ones [performed by the CLI](/docs/walrus-client/storing-blobs#consistency-checks) . For special use cases, the [strict consistency check](/docs/design/encoding) can be enabled by adding a query parameter `strict_consistency_check=true` (starting with `v1.35` ). If the writer of the blob is known and trusted, you can disable the consistency check by adding a query parameter `skip_consistency_check=true` (starting with `v1.36` ).

# Quilt HTTP APIs

URL: https://docs.wal.app/docs/http-api/quilt-http-apis

Walrus supports storing and retrieving multiple blobs **Blob** Single unstructured data object stored on Walrus. as a single unit called a [quilt](/docs/system-overview/quilt) . Publishers and aggregators both support quilt operations.

### Storing quilts

All query parameters available for storing regular blobs can also be used when storing quilts.

Use the following publisher **Publisher** Service interacting with Sui and the storage nodes to store blobs on Walrus; offers a basic `HTTP POST` endpoint to end users. API to store multiple blobs as a quilt.

```sh
# Store 2 files `document.pdf` and `image.png`, with custom identifiers `contract-v2` and `logo-2024`, respectively:
$ curl -X PUT "$PUBLISHER/v1/quilts?epochs=5" \
  -F "contract-v2=@document.pdf" \
  -F "logo-2024=@image.png"
```

Identifiers must be unique within a quilt and cannot start with `_` . The field name `_metadata` is reserved for Walrus native metadata and does not conflict with user **User** Any entity or person that wants to store or read blobs on or from Walrus; can act as a Walrus client itself or use the simple interface exposed by publishers and caches. -defined identifiers. See the [Quilt documentation](/docs/system-overview/quilt) for complete identifier restrictions.

```sh
# Store 2 files with Walrus-native metadata. `_metadata` must be used as the field name for Walrus native metadata
$ curl -X PUT "$PUBLISHER/v1/quilts?epochs=5" \
  -F "quilt-manual=@document.pdf" \
  -F "logo-2025=@image.png" \
  -F '_metadata=[
    {"identifier": "quilt-manual", "tags": {"creator": "walrus", "version": "1.0"}},
    {"identifier": "logo-2025", "tags": {"type": "logo", "format": "png"}}
  ]'
```

The quilt store API returns a JSON response with information about the stored quilt, including the quilt ID ( `blobId` ) and individual blob patch IDs that can be used to retrieve specific blobs later. The following example shows the command and response. The actual JSON output is returned as a single line and is formatted on this page for readability:

```sh
$ curl -X PUT "http://127.0.0.1:31415/v1/quilts?epochs=1" \
  -F "walrus.jpg=@./walrus-33.jpg" \
  -F "another_walrus.jpg=@./walrus-46.jpg"
```

If successful, the console responds:

```sh
{
  "blobStoreResult": {
    "newlyCreated": {
    "blobObject": {
        "id": "0xe6ac1e1ac08a603aef73a34328b0b623ffba6be6586e159a1d79c5ef0357bc02",
        "registeredEpoch": 103,
        "blobId": "6XUOE-Q5-nAXHRifN6n9nomVDtHZQbGuAkW3PjlBuKo",
        "size": 1782224,
        "encodingType": "RS2",
        "certifiedEpoch": null,
        "storage": {
        "id": "0xbc8ff9b4071927689d59468f887f94a4a503d9c6c5ef4c4d97fcb475a257758f",
        "startEpoch": 103,
        "endEpoch": 104,
        "storageSize": 72040000
        },
        "deletable": false
    },
    "resourceOperation": {
        "registerFromScratch": {
        "encodedLength": 72040000,
        "epochsAhead": 1
        }
    },
    "cost": 12075000
    }
  },
  "storedQuiltBlobs": [
    {
    "identifier": "another_walrus.jpg",
    "quiltPatchId": "6XUOE-Q5-nAXHRifN6n9nomVDtHZQbGuAkW3PjlBuKoBAQDQAA"
    },
    {
    "identifier": "walrus.jpg",
    "quiltPatchId": "6XUOE-Q5-nAXHRifN6n9nomVDtHZQbGuAkW3PjlBuKoB0AB7Ag"
    }
  ]
}
```

### Reading quilts

You can retrieve blobs from a quilt through the aggregator **Aggregator** Service that reconstructs blobs by interacting with storage nodes and exposes a basic `HTTP GET` endpoint to end users. APIs using their quilt patch ID or their quilt ID and unique identifier. Currently, only 1 blob can be retrieved per request. Bulk retrieval of multiple blobs from a quilt in a single request is not yet supported.

##### Quilt patch ID

Each blob in a quilt has a unique patch ID. You can retrieve a specific blob using its patch ID.

```sh
# Retrieve a blob using its quilt patch ID:
$ curl "$AGGREGATOR/v1/blobs/by-quilt-patch-id/6XUOE-Q5-nAXHRifN6n9nomVDtHZQbGuAkW3PjlBuKoBAQDQAA" \
```

You can obtain `QuiltPatchIds` from the store quilt output or by using the [`list-patches-in-quilt`](/docs/walrus-client/storing-blobs#batch-store) CLI command.

##### Quilt ID and identifier

You can also retrieve a blob using the quilt ID and the blob 's identifier.

```sh
# Retrieve a blob with identifier `walrus.jpg` from the quilt:
$ curl "$AGGREGATOR/v1/blobs/by-quilt-id/6XUOE-Q5-nAXHRifN6n9nomVDtHZQbGuAkW3PjlBuKo/walrus.jpg" \
```

Both methods return the raw blob bytes in the response body. Metadata such as the blob ID **Blob ID** Cryptographic ID computed from a blob's slivers. and tags are returned as HTTP headers:

- `X-Quilt-Patch-Identifier` : The identifier of the blob within the quilt
- `ETag` : The patch ID or quilt ID for caching purposes
- Additional custom headers from blob tags, if configured